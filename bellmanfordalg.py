# -*- coding: utf-8 -*-
"""BellmanFordAlg.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1U2LTTzqHSE0uRyCsUHCxp3VfJOw_4hwI
"""

def bellman_ford(graph, source):

    distances = {vertex: float('inf') for vertex in graph}
    distances[source] = 0

    for _ in range(len(graph) - 1):
        for edge in graph:
            u, v, weight = edge
            if distances[u] != float('inf') and distances[u] + weight < distances[v]:
                distances[v] = distances[u] + weight

    for edge in graph:
        u, v, weight = edge
        if distances[u] != float('inf') and distances[u] + weight < distances[v]:
            print("Graph contains negative weight cycle")
            return

    return distances

edges = [
    ('A', 'B', 4),
    ('A', 'C', 2),
    ('B', 'C', -3),
    ('B', 'D', 2),
    ('B', 'E', 3),
    ('D', 'C', 1),
    ('D', 'B', 1),
    ('E', 'D', -5)
]

vertices = set()
for edge in edges:
    vertices.add(edge[0])
    vertices.add(edge[1])

source_vertex = 'A'
shortest_distances = bellman_ford(edges, source_vertex)

print("Shortest distances from", source_vertex)
for vertex in vertices:
    print(f"Distance to {vertex}: {shortest_distances[vertex]}")